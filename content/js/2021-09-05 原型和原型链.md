---
title: "原型和原型链"
date: 2021-09-05T21:11:46+08:00
draft: false
tags:
 - 
---
## 题目
- 如何准确判断一个变量是`数组类型`
- 写一个原型链继承的例子
- 描述new一个对象的过程
### 知识点
- 构造函数
- 构造函数 - 扩展
- 原型规则和示例
- 原型链
- instanceof

#### 1.构造函数
函数有普通函数和构造函数; 构造函数大写首字母; new Fun(); Fun()就叫构造函数
```js
function Foo(name,age){
    this.name = name
    this.age = age
    this.class= 'class-1'
    //return this // 默认有这一行
}
var f = new Foo('zhangsan',20)
//var f1 = new Foo('lisi',22) // 创建多个对象
```

#### 2. 构造函数扩展
- `var a = {}`其实是`var a = new Object()`的语法糖
- `var a = []`其实是`var a = new Array()`的语法糖
- `function Foo(){...}`其实是`var Foo = new Function(...)`
- 使用`instanceof`判断一个函数是否是一个变量的构造函数

Exp:判断一个变量是否为数组 ? 
- 变量 `instanceof` Array
- let res = `Array.isArray(arr)`

#### 3. 原型规则和示例
```js
var obj = {} ; obj.a = 100
var arr = [] ; arr.a = 100

function fn(){}
fn.a = 100

console.log(obj.__proto__)
console.log(arr.__proto__)
console.log(fn.__proto__)

console.log(fn.prototype)

// obj的构造函数是Object
console.log(obj.__proto__===Object.prototype)
```
1. 所有的引用类型(对象,数组,函数), 都具有对象特性, 即可自由扩展属性
2. 所有的引用类型/`对象`, 都有一个`__proto__属性(隐式原型)`,属性值是一个普通的对象
3. 所有的`函数`,都有一个`prototype属性(显示原型)`,属性值也是一个普通的对象
4. 所有的引用类型(数组,对象,函数),__proto__属性值指向它的构造函数的prototype属性值
5. 当试图得到一个对象的某个属性时,如果这个对象本身没有这个属性,那么会去它的__proto__中寻找(即它的构造函数的prototype中寻找)


```js
// 构造函数
function Foo(name,age){
    this.name = name
}

Foo.prototype.alertName = function(){
    alert(this.name)
}
// 创建实例
var f = new Foo('zhangsan')
f.printName = function(){
    console.log(this.name)
}
// 测试
f.printName()
f.alertName()
f.toString() // 要去f.__proto__.__proto__中去查找
```

```js
var item
for(item in f) {
    // 高级浏览器已经在for in中屏蔽了来自原型的属性
    // 但是这里建议大家加上这个判断,保证程序的健壮性
    if(f.hasOwnProperty(item)){
        console.log(item)
    }
}
```

#### 4.原型链
![](https://gtd-imgs-md.oss-cn-beijing.aliyuncs.com/imgs/20210905233424.png#w60)
![](https://gtd-imgs-md.oss-cn-beijing.aliyuncs.com/imgs/20210905233459.png#w60)

---

#### 1. instanceof
用于判断`引用类型`属于哪个`构造函数`的方法

- f instanceof Foo 判断逻辑
1. f的__proto__一层一层往上,能否对应到Foo.prototype
- 再试着判断f instanceof Object   // true

#### 2.写一个原型链继承的例子
```js
function Animal(){
    this.eat = function(){
        console.log('animal eat')
    }
}

function Dog(){
    this.bark = function(){
        console.log('dog bark')
    }
}
// 面试不这么写?
Dog.prototype = new Animal()
// 哈士奇
var hashiqi = new Dog()
```
#### 3. 描述new一个对象的过程
- JS高程 P145
- 创建一个新对象;
- 将构造函数的作用域赋给新对象(因此this就指向了这个新对象)
- 执行构造函数中的代码(为这个新对象添加属性,对this赋值)
- 返回新对象(this)


--- 
1. [MDN: `__proto__`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto)
2. new过程 https://zhuanlan.zhihu.com/p/23987456
3. [prototype、[[prototype]]和__proto__](https://blog.csdn.net/qq_38722097/article/details/88046377)
4. [图解原型原型链 good!](https://juejin.cn/post/6844903797039300615)
5. [JS中原型链的理解](https://www.cnblogs.com/xfcao/p/10029731.html)

---
所有的函数都是 Function 的实例。
在构造函数上都有一个原型属性 prototype，该属性也是一个对象；
那么在原型对象上有一个 constructor 属性，该属性指向的就是构造函数；
而实例对象上有一个 _proto_  属性，该属性也指向原型对象，并且该属性不是标准属性，不可以用在编程中，该属性用于浏览器内部使用。


- JSjicheng https://www.cnblogs.com/ranyonsue/p/11201730.html