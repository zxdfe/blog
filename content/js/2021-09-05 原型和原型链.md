---
title: "原型和原型链"
date: 2021-09-05T21:11:46+08:00
draft: true
tags:
 - 
---
## 题目
- 如何准确判断一个变量是`数组类型`
- 写一个原型链继承的例子
- 描述new一个对象的过程
- zepto源码中如何使用原型链

### 知识点
- 构造函数
- 构造函数 - 扩展
- 原型规则和示例
- 原型链
- instanceof

#### 1.构造函数
```js
function Foo(name,age){
    this.name = name
    this.age = age
    this.class= 'class-1'
    //return this // 默认有这一行
}
var f = new Foo('zhangsan',20)
//var f1 = new Foo('lisi',22) // 创建多个对象
```

#### 2. 构造函数扩展
- `var a = {}`其实是`var a = new Object()`的语法糖
- `var a = []`其实是`var a = new Array()`的语法糖
- `function Foo(){...}`其实是`var Foo = new Function(...)`
- 使用`instanceof`判断一个函数是否是一个变量的构造函数

Exp:判断一个变量是否为数组 ? 
- 变量 `instanceof` Array
- let res = `Array.isArray(arr)`

#### 3. 原型规则和示例
```js
var obj = {} ; obj.a = 100
var arr = [] ; arr.a = 100

function fn(){}
fn.a = 100

console.log(obj.__proto__)
console.log(arr.__proto__)
console.log(fn.__proto__)

console.log(fn.prototype)

// obj的构造函数是Object
console.log(obj.__proto__===Object.prototype)
```
1. 所有的引用类型(对象,数组,函数), 都具有对象特性, 即可自由扩展属性
2. 所有的引用类型/`对象`, 都有一个`__proto__属性(隐式原型)`,属性值是一个普通的对象
3. 所有的`函数`,都有一个`prototype属性(显示原型)`,属性值也是一个普通的对象
4. 所有的引用类型(数组,对象,函数),__proto__属性值指向它的构造函数的prototype属性值
5. 当试图得到一个对象的某个属性时,如果这个对象本身没有这个属性,那么会去它的__proto__中寻找(即它的构造函数的prototype中寻找)


```js
// 构造函数
function Foo(name,age){
    this.name = name
}

Foo.prototype.alertName = function(){
    alert(this.name)
}
// 创建示例
var f = new Foo('zhangsan')
f.printName = function(){
    console.log(this.name)
}
// 测试
f.printName()
f.alertName()
f.toString() // 要去f.__proto__.__proto__中去查找
```

--- 
1. [MDN: `__proto__`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto)
1. new过程 https://zhuanlan.zhihu.com/p/23987456