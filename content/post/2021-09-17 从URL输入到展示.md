---
title: "从URL输入到展示"
date: 2021-09-17T10:20:34+08:00
draft: false
tags:
 - 
---

## 从进程的角度来看

![](https://gtd-imgs-md.oss-cn-beijing.aliyuncs.com/imgs/20210917102703.png)
- 浏览器进程: 主要负责用户交互、子进程管理和文件储存等功能。
- 网络进程: 面向渲染进程和浏览器进程等提供网络下载功能。
- 渲染进程: 主要职责是把从网络下载的 HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。

## 过程大致如下
1. 首先，浏览器进程接收到用户输入的 URL 请求，浏览器进程便将该 URL 转发给网络进程。
2. 然后，在网络进程中发起真正的 URL 请求。
3. 接着网络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程。
4. 浏览器进程接收到网络进程的响应头数据之后，发送“提交导航 (CommitNavigation)”消息到渲染进程；
5. 渲染进程接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立数据管道；
6. 最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程：“已经准备好接受和解析页面数据了”。
7. 浏览器进程接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态。

其中, `用户发出 URL 请求到页面开始解析的这个过程，就叫做导航` (对照 NavigationTiming)

## 具体
### 1. 用户输入
地址栏判断用户输入的内容是`搜索内容`, 还是`请求的URL`

- 搜索内容: 地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL;
- 如果判断输入内容符合 URL 规则，比如输入的是baidu.com，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL，如 https://www.baidu.com。

当用户输入关键字并键入回车后,如果页面做了`beforunload事件`监听, 用户可以通过`beforeunload`事件来取消导航,让浏览器不再执行后续工作

如果页面没有监听`beforeunload事件`或者同意了后续流程, tab标签图标进入加载状态;此时页面依旧是之前打开的内容, 并没有立即替换为新页面; 因为需要等待`提交文档阶段`,页面内容才会被替换;

### 2. URL请求过程
接下来, 进入页面资源请求过程.
`浏览器进程`会通过`进程间通信(IPC)`把URL请求发送到`网络进程`,网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程

首先,网络进程会查找本地缓存是否缓存了该资源。
- 如果有缓存资源，那么直接返回资源给浏览器进程；
- 如果在缓存中没有查找到资源，那么直接进入网络请求流程.
  - 请求前的第一步是要进行 DNS 解析，以获取请求域名的服务器 IP 地址。
  - 如果请求协议是 HTTPS，那么还需要建立 TLS 连接。

接下来就是利用 IP 地址和服务器建立 TCP 连接。
连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。

服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。

**重定向**

在接收到服务器返回的响应头后，网络进程开始解析响应头, 如果返回的状态码是 `301(Moved Permanently)` 或者 `302(Temporarily Moved)`, 说明服务器需要浏览器重定向到其他 URL。
这时, 网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求 , 一切重新开始.

`curl -I + URL`命令 : 接收服务器返回的响应头的信息

![](https://gtd-imgs-md.oss-cn-beijing.aliyuncs.com/imgs/20210917112237.png)
![](https://gtd-imgs-md.oss-cn-beijing.aliyuncs.com/imgs/20210917112558.png)

如果服务器返回的响应头状态码是200, 就可以继续往下处理该请求了.

**响应数据类型处理**

`Content-Type 是 HTTP 头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型`, 浏览器的`Content-Type`告诉服务器期望的响应体内容格式, 最终会根据服务器来决定响应体的内容格式.
![](https://gtd-imgs-md.oss-cn-beijing.aliyuncs.com/imgs/20210917113255.png)
![](https://gtd-imgs-md.oss-cn-beijing.aliyuncs.com/imgs/20210917113708.png)

`content-type: application/octet-stream`告诉浏览器, 返回的是`字节流类型`, 通常浏览器会按照`下载类型`来处理;

所以，不同 Content-Type 的后续处理流程也截然不同。
- 如果 Content-Type 字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束。
- 但如果是 HTML，那么浏览器则会继续进行导航流程。由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。

### 3. 准备渲染进程

**同一站点** : `根域名(geekbang.org)`+`协议(https://  https://)`,同时包含该根域名下所有子域名和不同端口
```
https://time.geekbang.org
https://www.geekbang.org
https://www.geekbang.org:8080
```
Chrome 的默认策略是，每个标签对应一个渲染进程。但**如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程**。官方把这个默认策略叫 process-per-site-instance。

打开一个新页面采用的渲染进程策略就是：
- 通常情况下，打开新的页面都会使用单独的渲染进程；
- 如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。

渲染进程准备好之后，还不能立即进入`文档解析状态`，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了`提交文档阶段`。

### 4. 提交文档
`提交文档，就是指浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程`, 具体流程是这样的：
- 首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；
- 渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；
- 等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；
- 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。

当渲染进程确认提交之后,更新了如下内容
1. 更新前进后退状态
2. 更新安全状态
3. 更新地址URL
4. 更新web页面
![](https://gtd-imgs-md.oss-cn-beijing.aliyuncs.com/imgs/20210917141918.png)

到这里，一个完整的导航流程就“走”完了，这之后就要进入渲染阶段了。

### 5. 渲染阶段
一旦文档被提交，渲染进程便开始页面解析和子资源加载了.

一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画.

### 总结
1. 服务器可以根据响应头来控制浏览器的行为，如跳转、网络数据类型判断。
2. Chrome 默认采用每个标签对应一个渲染进程，但是如果两个页面属于同一站点，那这两个标签会使用同一个渲染进程。
3. 浏览器的导航过程涵盖了从用户发起请求到提交文档给渲染进程的中间所有阶段。