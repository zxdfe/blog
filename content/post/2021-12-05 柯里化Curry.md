---
title: "柯里化Curry"
date: 2021-12-05T21:11:44+08:00
draft: false
tags:
 - JS
---
## 柯里化 Curry

柯里化是一个把具有较多参数的函数转换成具有较少参数函数的过程 -- Kristina Brainwave

柯里化是编程语言中的一个通用的概念（不只是Js，其他很多语言也有柯里化），是指**把接收多个参数的函数变换成接收单一参数的函数**，嵌套返回直到所有参数都被使用并返回最终结果。更简单地说，**柯里化是一个函数变换的过程，是将函数从调用方式：`f(a,b,c)`变换成调用方式：`f(a)(b)(c)`的过程**。柯里化不会调用函数，它只是对函数进行转换。

```js
function add(a, b, c) {
    return a + b + c;
}

// 执行 add 函数，一次传入三个参数即可
add(1, 2, 3) // 3

// 假设有一个 curry 函数可以做到柯里化
var addCurry = curry(add);
addCurry(1)(2)(3) // 6
```

curry 柯里化实际是把简单的问题复杂化了，但是复杂化的同时，我们在使用函数时拥有了更加多的自由度。

- Curry可以理解为：**参数复用**。本质上是**降低通用性，提高适用性**。

柯里化其实是函数式编程的一个过程，在这个过程中我们能把一个带有多个参数的函数转换成一系列的嵌套函数。它返回一个新函数，这个新函数期望传入下一个参数

它不断地返回新函数（像我们之前讲的，这个新函数期望当前的参数），直到所有的参数都被使用。参数会一直保持 `alive`（通过闭包），当柯里化函数链中最后一个函数被返回和调用的时候，它们会用于执行。

我们把addCurry拆分一下，以便更好理解

```js
// addCurry(1)(2)(3) // 6
function addCurry(a){
  return (b) => {
    return (c) => {
      return a + b + c
    }
  }
}

const add1 = addCurry(1)
const add2 = add1(2)
const result = add2(3)
console.log(result)  // 6
```

让我们依次调用他们，首先传1给addCurry()函数

```js
const add1 = addCurry(1)
// 返回
return (b) => {
    return (c) => {
      return a + b + c
    }
}
// add1持有上面这个函数的定义，它接受一个参数b
add1 = (b) => {
  return c => {
    return a + b +c
  }
}
```

我们调用add1函数，传递参数2

```js
let add2 = add1(2)

add2 = (c) => {
  return a + b + c
}

```

当传递参数3给add2并调用它,  它和之前传递进来的参数 a = 1 , b = 2 做了计算，返回了6

```js
const result = add2(3)  // 6
```

这里涉及到闭包的知识，作为嵌套函数，先前传入的参数都处于alive状态，并没有被释放。

**被柯里化的版本将接受一个参数并且返回一个函数，这个新函数依然会接受一个参数并且返回一个新函数。这个过程会一直持续，直到最后一个参数到达并且返回最后一个函数，最后返回的函数会使用之前接受的参数和最后一个参数进行运算返回结果。**

**柯里化背后的想法是，接受一个函数并且得到一个函数，这个函数返回专用的函数**

- **用闭包把参数保存起来，当参数的数量足够执行函数了，就开始执行函数**



## 数学中的概念

https://en.m.wikipedia.org/wiki/Currying

![image-20211205174100120](https://zxd-blog-imgs.oss-cn-beijing.aliyuncs.com/imgs/20211205174100.png)

## 柯里化的应用

1. **编写小模块的代码，可以更轻松的重用和配置，就行 npm 做的那样**

2. **避免频繁调用具有相同参数的函数：**

3. **参数复用、提前返回和延迟执行**

   提前返回 和 延迟执行 也很好理解，因为每次调用函数时，它只接受一部分参数，并返回一个函数（提前返回），直到(延迟执行)传递所有参数为止

4. 函数式编程



## 通用的柯里化函数

```js
// 测试过！ok
const curry = (fn, ...args) =>{
  // 当参数与fn参数相同，则直接执行函数
	if (args.length >= fn.length) return fn(...args)
  // 否则返回函数，合并参数，并继续自动柯里化
    return (...args2) => {
        return curry(fn, ...args, ...args2);
    }
}
```

我们在这里做了什么呢？我们的柯里化函数接受一个我们希望柯里化的函数（fn），还有一系列的参数（...args）。扩展运算符是用来收集`fn`后面的参数到`...args`中。

接下来，我们返回一个函数，这个函数同样将剩余的参数收集为`..._args`。这个函数将`...args`传入原始函数`fn`并调用它，通过使用扩展运算符将`..._args`也作为参数传入，然后，得到的值会返回给用户。

---





1. [「译」理解JavaScript的柯里化]( https://zhuanlan.zhihu.com/p/50247174) 知乎

2. [「前端进阶」彻底弄懂函数柯里化](https://juejin.cn/post/6844903882208837645) 

3. [彻底搞懂闭包，柯里化，手写代码，金九银十不再丢分！](https://juejin.cn/post/6864378349512065038#heading-28)

4. [一文搞懂Javascript中的函数柯里化（currying）]( https://zhuanlan.zhihu.com/p/120735088)

5. [JavaScript专题之函数柯里化]( https://github.com/mqyqingfeng/Blog/issues/42)

   
