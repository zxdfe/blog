---
title: "垃圾收集"
date: 2021-05-13T23:13:05+08:00
draft: true
tags:
 - 
---
## 垃圾收集
JavasScript具有自动垃圾收集机制, 执行环境会负责管理代码执行过程中使用的内存.

### 标记清除
JavaScript中最常用的垃圾收集方式是`标记清除(mark-and-sweep)`.

当变量进入环境时(在函数中声明一个变量),就将这个变量标记为`进入环境`, 当变量离开环境时则将其标记为`离开环境`, 永远不能释放进入环境的变量.

垃圾收集器在运行时会给存储在内存中的所有变量都加上标记,然后去掉环境中的变量以及被环境中的变量引用的变量的标记,而此后再被加上标记的变量将被视为准备删除的变量.

最后,垃圾收集器完成`内存清理`工作,销毁那些带标记的值并回收它们所占用的内存空间

### 引用计数
另一种不太常见的垃圾收集策略叫`引用计数(reference counting)`, 引用计数的含义是跟踪记录每个值被引用的次数.

当声明了一个变量并将一个引用类型值赋值给该变量时, 这个值的引用次数记为1. 如果同一个值又被赋值给另一个变量, 则该值的引用次数加1.  相反, 当包含对这个值引用的变量又重新赋值了, 则这个值的引用次数减1, 当这个值的引用次数为0时 , 垃圾收集器下次再运行时,就会释放引用次数为0的值所占用的内存

**弊端: 循环引用**
```js
function problem() {
    var objectA = new Object()
    var objectB = new Object()

    objectA.someOtherObject = objectB
    objectB.anotherObject = objectA
}
// 两个对象的引用次数都为2, 函数执行完毕后也继续存在
```
Netscape Navigator 3.0是最早使用引用计数策略的浏览器,4.0放弃这种方式;

IE中的BOM和DOM对象是使用C++以COM(component Object Model,组件对象模型)对象的形式实现的,而COM对象的垃圾收集机制采用的是引用计数策略. `IE9把BOM和DOM对象转换成了真正的JS对象,从而避免两种垃圾收集算法并存导致的问题`

即使IE的JavaScript引擎使用的标记清除策略实现,但JS访问的COM对象依然是基于引用计数策略.即,只要在IE中设计COM对象,就会存在循环引用的问题.

**如何避免(IE)**
手动断开原生JavaScript对象与DOM元素之间的连接
```js
myObject.element = null
element.someObject = null
```

### 性能问题
垃圾收集器是周期性运行的,且回收工作量相当大,如何确定垃圾收集的时间间隔是一个非常重要的问题.

IE6存在很大性能问题,IE7重写了垃圾收集例程

有些浏览器可以手动触发垃圾收集过程,但不建议这么做
- IE, 调用`window.collectGarbage()`,会立即执行垃圾收集
- Opera 7及更高版本 `window.opera.collect()`

### 管理内存
计算机分配给Web浏览器的可用内存数量通常比分配给桌面应用程序的少,`内存限制`问题不仅会影响给变量分配内存, 同时还会影响调用栈以及在一个线程中能够同时执行的语句数量.

因此, 确保占用最少的内存可以让页面获得更好的性能.

而优化内存占用的最佳方式, 就是为执行中的代码只保存必要的数据.`一旦数据不再有用, 最好通过将值设置为null来释放其引用-- 这个做法叫做**解除引用**` , 适用于大多数的全局变量和全局对象的属性. `局部变量会在它们离开执行环境时自动被解除引用`

```js
function createPerson(name) {
    var localPerson = new Object()
    localPerson.name = name
    return localPerson
}

var globalPerson = createPerson("Nicholas")

// 手动解除引用
globalPerson = null
```
注意的是,解除一个值的引用并不意味着自动回收该值所占用的内存. `解除引用的真正作用是让值脱离执行环境, 以便垃圾收集器下次运行时将其回收`