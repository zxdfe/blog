---
title: "JS执行过程"
date: 2021-12-02T23:39:19+08:00
draft: true
tags:
 - 
---
## 变量提升 (Hoisting)

### 变量的声明和赋值

![img](https://gtd-imgs-md.oss-cn-beijing.aliyuncs.com/imgs/20211203115319.png)



### 函数的声明和赋值

![img](https://gtd-imgs-md.oss-cn-beijing.aliyuncs.com/imgs/20211203115323.png)



- 变量提升，是指**在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。**
- 变量被提升后，会给变量设置默认值 **undefined**

#### 变量提升带来的问题

1. 变量容易在不被察觉的情况下被覆盖掉
2. 本应销毁的变量没有被销毁

## JavaScript 代码的执行流程

- **实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中**
- 一段 JavaScript 代码在执行之前需要被 JavaScript 引擎编译，编译完成之后，才会进入执行阶段

```js
// JS执行流程
一段JS代码  --> 编译阶段 -- > 执行阶段
```

![img](https://gtd-imgs-md.oss-cn-beijing.aliyuncs.com/imgs/20211203115337.png)

### 编译阶段

输入一段代码，经过编译后，会生成两部分内容：执行上下文（Execution context）和可执行代码。

---



##### 执行上下文

![img](https://gtd-imgs-md.oss-cn-beijing.aliyuncs.com/imgs/20211203115342.png)

从上图可以看出，输入一段代码，经过编译后，会生成两部分内容：**执行上下文（Execution context）**和**可执行代码**。

**执行上下文 （Execution context）是 JavaScript 执行一段代码时的运行环境,**也可以叫做**执行环境**

- 全局执行上下文

- 函数执行上下文

- eval执行上下文

  

执行上下文中又包含 

- **变量环境** （Variable Environment）
- **词法环境** （Lexical Environment）
- 外部环境  （outer）
- **this**

![img](https://gtd-imgs-md.oss-cn-beijing.aliyuncs.com/imgs/20211203115347.png)

- 变量环境的对象（Viriable Environment）中保存了变量提升的内容

---

### 执行阶段

生成了变量环境对象后， JS引擎会把声明以外的代码编译为字节码（可执行代码），之后进入执行阶段

JavaScript 引擎按照顺序一行一行地执行“可执行代码”。



### 遇到同名变量或函数

如果代码中出现了重名的函数或者变量

```js
function showName() {
    console.log('极客邦');
}
showName();
function showName() {
    console.log('极客时间');
}
showName(); 
```

- 编译阶段，第二个showName会覆盖前一个， 变量对象中只存在第二个函数

- 执行阶段，两次都是调用第二个函数， 打印两次‘极客时间

  >  JavaScript 的执行机制：先编译，再执行。’



## 调用栈

### 一段代码

- 全局代码  --> 创建全局执行上下文， 整个页面生命周期，全局执行上下文只有一份
- 函数代码  --> 调用一个函数时， 函数体内代码会被编译，并创建函数执行上下文
- eval代码  --> 当使用eval函数的时候偶， eval代码也会被编译，并创建执行上下文

### 调用栈

JavaScript 中有很多函数，经常会出现在一个函数中调用另外一个函数的情况，**调用栈就是用来管理函数调用关系的一种数据结构。**

在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。

**调用栈是 JavaScript 引擎追踪函数执行的一个机制**，当一次有多个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关系。

LIFO: 栈满足后进先出的特点

#### 什么是函数调用

函数调用就是运行一个函数，具体使用方式是使用函数名称跟着一对小括号

#### 函数调用过程

![img](https://gtd-imgs-md.oss-cn-beijing.aliyuncs.com/imgs/20211203115432.png)



### Call Stack断点调试

![img](https://gtd-imgs-md.oss-cn-beijing.aliyuncs.com/imgs/20211203115407.png)



- 栈底： anonymous 全局函数入口
- console.trace() ： 输出当前的函数调用关系

### 栈溢出 (Stack Overflow)

调用栈是有大小的，当入栈的执行上下文超过一定数目，JavaScript 引擎就会报错，我们把这种错误叫做栈溢出

特别是写递归代码的时候，就很容易出现栈溢出的情况

```js
function division(a,b){
    return division(a,b)
}
console.log(division(1,2))
```

执行时就会抛出栈溢出错误：超过了最大栈调用大小（Maximum call stack size exceeded）

![img](https://gtd-imgs-md.oss-cn-beijing.aliyuncs.com/imgs/20211203115437.png)



可以把递归的形式改成其他形式，或者使用加入定时器的方法来把当前任务拆分为其他很多小任务。

[为什么使用定时器可以解决栈溢出问题？](https://juejin.cn/post/6844903890270289928#heading-15)



## 作用域 （scope）

### **作用域**

**就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。**

ES6之前，ES作用域只有：

 - **全局作用域** (Global Scope): 中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。
 -  **函数作用域** (Local Scope) :  JS的作用域是通过函数来定义的,  在一个函数中定义的变量只对这个函数内部可见, 称为函数(局部)作用域

ES6新增

 - **块级作用域：块级作用域内声明的变量不影响外面的变量**

## 闭包

1. [JavaScript闭包的底层运行机制](http://blog.leapoahead.com/2015/09/15/js-closure/)

## 

## 参考



1. [面试官：说说作用域和闭包吧](https://juejin.cn/post/6844904165672484871#heading-19)

2. [JavaScript 的静态作用域链与“动态”闭包链](https://juejin.cn/post/6957913856488243237)
3. [JS 闭包经典使用场景和含闭包必刷题](https://juejin.cn/post/6937469222251560990)
4. [[核心概念] 一文说透 JS 中的执行上下文](https://juejin.cn/post/6890705692643196935)  good!
5. 极客时间专栏：浏览器工作原理与实践
6. [JavaScript深入之执行上下文栈](https://github.com/mqyqingfeng/Blog/issues/4) 
7. [一道js面试题引发的思考](https://github.com/kuitos/kuitos.github.io/issues/18)

![image-20211202202428125](https://gtd-imgs-md.oss-cn-beijing.aliyuncs.com/imgs/20211203115444.png)




